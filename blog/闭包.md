# 什么是闭包？

## 今天的主要内容为

## 简述闭包相关内容

1. [什么是闭包？](#jump1)
2. [闭包的用途是什么？](#jump2)
3. [闭包的缺点是什么？](#jump3)

## 开始吧

###  <span id="jump1">1. 闭包是什么？</span>
* 一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。
* 通俗一点，如果一个函数执行完之后，里面的变量还没被销毁掉，那么它就是一个闭包
  ```css
  function init() {
   var name = "Mozilla"; // name 是一个被 init 创建的局部变量
   function displayName() { // displayName() 是内部函数，一个闭包
       alert(name); // 使用了父函数中声明的变量
      }
      displayName();
    }
   init();
  ```

###  <span id="jump2">2. 闭包的用途是什么？</span>
闭包可以用在许多地方。它的最大用处有两个：
* 可以读取函数内部的变量
* 让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。
```css
　　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}

　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}

　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000

```
* 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
* 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
* 这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。


###  <span id="jump3">3. 闭包的缺点是什么？</span>

 * 优点
   1. 可以避免全局变量的污染
   2. 可以读取函数内部的变量
 * 缺点
   1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
   2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
   
### 补充：

1. 嵌套函数中，外部函数可以通过闭包访问外部函数；
2. 慎重使用闭包；
   